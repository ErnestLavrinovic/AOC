using System;
using System.IO;
using System.Linq;
using System.Collections.Generic;

class PermutationGenerator
{
    public static List<List<int>> GetPermutations(List<int> input)
    {
        return Generate(input, new List<int>());
    }

    private static List<List<int>> Generate(List<int> remaining, List<int> current)
    {
        List<List<int>> result = new List<List<int>>();

        if (remaining.Count == 0)
        {
            result.Add(new List<int>(current));
            return result;
        }

        for (int i = 0; i < remaining.Count; i++)
        {
            int item = remaining[i];

            List<int> nextRemaining = new List<int>(remaining);
            nextRemaining.RemoveAt(i);

            List<int> nextCurrent = new List<int>(current);
            nextCurrent.Add(item);

            result.AddRange(Generate(nextRemaining, nextCurrent));
        }

        return result;
    }
}

class AmpState
{
    public int[] memory;
    public int pos;
    public Queue<int> inputs;
    public bool halted;
}

namespace AOC__2018_day1_part1 //2019 day 7 part 2 im lazy to change projects
{
    internal class Program
    {
        private static void Main(string[] args)
        {
            string input = File.ReadAllText("C:/Users/HP//source/repos/AOC  2018 day1 part1/AOC  2018 day1 part1/input.txt");
            //Console.WriteLine(input);
            int[] numbers = input.Split(',').Select(int.Parse).ToArray();
            int[] memory = numbers.ToArray();

            int max = int.MinValue;
            var perms = PermutationGenerator.GetPermutations(new List<int> { 5, 6, 7, 8, 9 });
            foreach (var perm in perms)
            {
                int[] array = perm.ToArray();

                var amps = new List<AmpState>();
                for (int i = 0; i < 5; i++)
                {
                    amps.Add(new AmpState
                    {
                        memory = numbers.ToArray(),
                        pos = 0,
                        inputs = new Queue<int>(new[] { array[i] }),
                        halted = false
                    });
                }

                amps[0].inputs.Enqueue(0); // Initial input signal

                int lastOutput = 0;
                while (!amps[4].halted)
                {
                    for (int i = 0; i < 5; i++)
                    {
                        var output = RunProgram(amps[i]);
                        if (output.HasValue)
                        {
                            lastOutput = output.Value;
                            amps[(i + 1) % 5].inputs.Enqueue(lastOutput);
                        }
                    }
                }

                if (lastOutput > max)
                {
                    max = lastOutput;
                    Console.WriteLine("New max found!");
                    Console.WriteLine("Phase setting: " + string.Join(",", array));
                    Console.WriteLine("Signal: " + max);
                }
            }

            Console.ReadLine();
        }
        private static int? RunProgram(AmpState state)
        {
            int[] numbers = state.memory;
            int pos = state.pos;
            Queue<int> inputs = state.inputs;

            while (pos < numbers.Length)
            {
                int instruction = numbers[pos];
                int opcode = instruction % 100;
                int mode1 = (instruction / 100) % 10;
                int mode2 = (instruction / 1000) % 10;

                if (opcode == 99)
                {
                    state.halted = true;
                    break;
                }

                switch (opcode)
                {
                    case 1:
                        {
                            int a = GetParameter(numbers, numbers[pos + 1], mode1);
                            int b = GetParameter(numbers, numbers[pos + 2], mode2);
                            int c = numbers[pos + 3];
                            numbers[c] = a + b;
                            pos += 4;
                            break;
                        }
                    case 2:
                        {
                            int a = GetParameter(numbers, numbers[pos + 1], mode1);
                            int b = GetParameter(numbers, numbers[pos + 2], mode2);
                            int c = numbers[pos + 3];
                            numbers[c] = a * b;
                            pos += 4;
                            break;
                        }
                    case 3:
                        {
                            if (inputs.Count == 0)
                            {
                                state.pos = pos; // Save position
                                return null; // Pause execution 
                            }
                            numbers[numbers[pos + 1]] = inputs.Dequeue();
                            pos += 2;
                            break;
                        }
                    case 4:
                        {
                            int mode = (instruction / 100) % 10;
                            int output = GetParameter(numbers, numbers[pos + 1], mode);
                            pos += 2;
                            state.pos = pos; // Save position
                            return output;   // Pause and return output
                        }
                    case 5:
                        {
                            int a = GetParameter(numbers, numbers[pos + 1], mode1);
                            int b = GetParameter(numbers, numbers[pos + 2], mode2);
                            pos = a != 0 ? b : pos + 3;
                            break;
                        }
                    case 6:
                        {
                            int a = GetParameter(numbers, numbers[pos + 1], mode1);
                            int b = GetParameter(numbers, numbers[pos + 2], mode2);
                            pos = a == 0 ? b : pos + 3;
                            break;
                        }
                    case 7:
                        {
                            int a = GetParameter(numbers, numbers[pos + 1], mode1);
                            int b = GetParameter(numbers, numbers[pos + 2], mode2);
                            numbers[numbers[pos + 3]] = a < b ? 1 : 0;
                            pos += 4;
                            break;
                        }
                    case 8:
                        {
                            int a = GetParameter(numbers, numbers[pos + 1], mode1);
                            int b = GetParameter(numbers, numbers[pos + 2], mode2);
                            numbers[numbers[pos + 3]] = a == b ? 1 : 0;
                            pos += 4;
                            break;
                        }
                }
            }

            state.pos = pos; // Save position at end
            return null;
        }

        static int GetParameter(int[] memory, int value, int mode)
        {
            return mode == 0 ? memory[value] : value;
        }
    }
}